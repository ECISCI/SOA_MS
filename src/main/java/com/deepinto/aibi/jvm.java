package com.deepinto.aibi;

public class jvm {

    /**
     * @1 Java虚拟机运行时数据区域划分
     */
    /*1. 堆 heap
     *
     *2. 栈 Stack
     *
     *3. 本地方法栈(Native stack)
     *
     *4. 方法区(Method Area)
     *
     *5. 程序计数器(ProgramCountRegister)
     */

    /**
     * @2 堆（Heap）
     */
    /*
     *对于大多数应用来说,Java Heap是Java虚拟机管理的内存的最大一块,这块区域随着
     *
     * 虚拟机的启动而创建,在实际的运用中,我们创建的对象和数组就是存放在堆里面
     *
     * 如果你听说线程安全的问题,就会很明确的知道Java Heap是一块"共享的区域"
     *
     * 操作共享区域的成员就有了锁和同步
     *
     * 与Java Heap相关的还有Java垃圾回收机制（GC）Java Heap是垃圾回收器管理的主要区域
     *
     * 程序员锁熟悉的新生代,老生代,永久代的概念就是在堆里面,现在大多数的GC基本都采用
     *
     * "分代收集算法" 如果细致一点,Java Heap还有Eden空间
     *
     * From Survivor 空间 To Survivor
     *
     * Java Heap可以处于物理上不连续的内存空间中,只要在逻辑上是连续的即可
     *
     * */

    /**
     * @Stack 栈区
     * */
    /* 相对于Java Heap来讲,Java Stack是线程私有的,它的生命周期与线程相同
     *
     * Java Stack描述的是Java方法执行时的内存模型
     *
     * "每个方法执行时都会创建一个栈帧(Stack Frame)"
     *
     * 用于存储局部变量表,操作数栈,动态链接,方法出口等信息
     *
     * 每个线程在执行一个方法时,都意味着有一个栈帧在当前线程对应的栈帧中入栈出栈
     *
     * 每一个栈帧中都有局部变量表,局部变量表存放了编译期间的各种基本数据类型,对象引用等信息
     * */

    /**
     * @4 Native Stack 本地方法栈
     */
    /*本地方法栈(Native Stack)与Java虚拟机栈(Java Stack)所发挥的作用非常相似
     *
     *他们之间的区别在于虚拟机栈为虚拟机栈执行Java方法(也就是字节码)服务
     *
     * 而本地方法栈则为使用到Native方法服务
     */

    /**
     * @5 方法区
     */
    /* 方法区与堆区一样 是各个线程共享的内存区域,它用于存储虚拟机加载的
     *
     * 类信息 常量 静态变量 即时编译器编译后的代码等数据
     *
     * 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,
     *
     * 但是它确有一个别名叫做非堆(non-heap)
     *
     * 分析下Java虚拟机规范,之所以把方法区描述为堆的一个逻辑部分,应该觉得它们都是
     *
     * 存储数据的角度出发的,一个存储对象数据(堆)一个存储静态信息(方法区)
     */

}
